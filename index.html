<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Upload sécurisé</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:24px auto;max-width:900px;color:#111;padding:0 16px}
    label{display:block;margin-top:12px;font-weight:600}
    input,textarea,button{width:100%;padding:10px;border:1px solid #d1d5db;border-radius:8px;box-sizing:border-box}
    button{background:#0366d6;color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer}
    .muted{color:#6b7280;font-size:0.95rem}
    .log{white-space:pre-wrap;background:#f8fafc;padding:12px;border-radius:8px;margin-top:12px;border:1px solid #e6eef8;max-height:240px;overflow:auto}
    progress{width:100%;height:14px;border-radius:8px;display:none}
  </style>
</head>
<body>
  <header>
    <h1>Upload sécurisé</h1>
    <p class="muted"><strong>Ne jamais</strong> inclure la service_role dans le frontend. Les clés réelles doivent être injectées par CI via GitHub Secrets.</p>
  </header>

  <main>
    <label for="file">Fichier</label>
    <input id="file" type="file" />

    <label for="manufacturer">Fabricant</label>
    <input id="manufacturer" type="text" placeholder="ex: Otis" />

    <label for="model">Modèle</label>
    <input id="model" type="text" placeholder="ex: MX200" />

    <label for="description">Description (optionnel)</label>
    <textarea id="description" rows="3"></textarea>

    <button id="start">Démarrer l'upload</button>
    <div id="status" class="muted">Prêt</div>

    <progress id="progress" value="0" max="100"></progress>
    <div class="log" id="log">Journal d'activité</div>

    <section style="margin-top:16px">
      <h3>Configuration</h3>
      <pre class="muted" style="background:#fff;padding:8px;border-radius:6px;border:1px solid #eef2ff;">
const SUPABASE_URL = 'REPLACE_WITH_SUPABASE_URL';
const SUPABASE_ANON_KEY = 'REPLACE_WITH_ANON_KEY';
const FN_UPLOAD_REQUEST = 'REPLACE_WITH_FN_UPLOAD_REQUEST';
const FN_CONFIRM_UPLOAD = 'REPLACE_WITH_FN_CONFIRM_UPLOAD';
      </pre>
    </section>
  </main>

  <footer style="margin-top:16px" class="muted">
    Injecter SUPABASE_ANON_KEY et SUPABASE_URL via GitHub Secrets; ne pas stocker de clés dans le repo.
  </footer>

  <script>
    const SUPABASE_URL = 'REPLACE_WITH_SUPABASE_URL';
    const SUPABASE_ANON_KEY = 'REPLACE_WITH_ANON_KEY';
    const FN_UPLOAD_REQUEST = 'REPLACE_WITH_FN_UPLOAD_REQUEST';
    const FN_CONFIRM_UPLOAD = 'REPLACE_WITH_FN_CONFIRM_UPLOAD';

    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    const progressEl = document.getElementById('progress');

    function log(...args){
      const ts = new Date().toISOString().replace('T',' ').split('.')[0];
      logEl.textContent = `[${ts}] ` + args.join(' ') + '\n' + logEl.textContent;
    }

    function setStatus(t){ statusEl.textContent = t; }

    function checkPlaceholders(){
      if(SUPABASE_ANON_KEY === 'REPLACE_WITH_ANON_KEY'){
        log('ATTENTION: SUPABASE_ANON_KEY est un placeholder. Injecter la vraie clé via GitHub Secrets au build.');
        setStatus('Clé non injectée');
        return false;
      }
      return true;
    }

    async function startUpload(){
      log('Démarrage upload');
      if(!checkPlaceholders()){ alert('La clé ANON n\'est pas injectée. Voir le journal.'); return; }

      const fileInput = document.getElementById('file');
      if(!fileInput.files.length){ alert('Choisir un fichier'); return; }
      const file = fileInput.files[0];
      const manufacturer = document.getElementById('manufacturer').value || null;
      const model = document.getElementById('model').value || null;
      const description = document.getElementById('description').value || null;

      try {
        setStatus('Demande URL signée');
        const signRes = await fetch(FN_UPLOAD_REQUEST, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename: file.name, mimeType: file.type || 'application/octet-stream', manufacturer, model })
        });
        if(!signRes.ok) throw new Error('upload-request failed ' + signRes.status);
        const signJson = await signRes.json();
        const uploadUrl = signJson.uploadUrl || signJson.signedUrl || signJson.url;
        const storagePath = signJson.path;
        if(!uploadUrl || !storagePath) throw new Error('Réponse upload-request invalide');

        setStatus('Upload vers stockage');
        progressEl.style.display = 'block';
        progressEl.value = 30;

        const putRes = await fetch(uploadUrl, { method: 'PUT', headers: { 'Content-Type': file.type || 'application/octet-stream' }, body: file });
        if(!(putRes.ok || putRes.status === 200 || putRes.status === 201)) throw new Error('Erreur PUT storage ' + putRes.status);

        progressEl.value = 80;
        setStatus('Confirmation metadata');
        const confirmRes = await fetch(FN_CONFIRM_UPLOAD, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: storagePath, filename: file.name, filetype: file.type || null, manufacturer, model, description })
        });
        if(!confirmRes.ok) throw new Error('confirm-upload failed ' + confirmRes.status);
        const confirmJson = await confirmRes.json();

        progressEl.value = 100;
        setStatus('Terminé');
        log('Upload OK, metadata:', JSON.stringify(confirmJson));
      } catch(err){
        log('Erreur:', err.message || err);
        setStatus('Erreur');
      } finally {
        setTimeout(()=>{ progressEl.style.display = 'none'; progressEl.value = 0; }, 1200);
      }
    }

    document.getElementById('start').addEventListener('click', startUpload);
  </script>
</body>
</html>
